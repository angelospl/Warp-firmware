Filter : module ()
{
        N : const 100;
        M : const 5000;
        lowPassFilterOrder61 : function (input : array [100] of float32)
        				-> (output : array [100] of float32);
	getXAccelerationMeasurement : function (nil) -> (ret : int16);
	noisyWarpPrintFloat32 : function (x : float32) -> (nil);
        lowPassFilter61 : function (nil) -> (nil);
}

# Implementation of a filter using channels and coroutines
lowPassFilterOrder61 : function (input : array [100] of float32)
					-> (output : array [100] of float32) =
{
	# Initialize coefficient values
	coeff := array of { float32 0.000227909254804652, 0.000433867017147087, 0.000780047144163945,
	0.001226644358132, 0.00173493436088177,0.00223040625529593, 0.00260254806414593,
	0.00271072221695493, 0.00239864483731844, 0.00151692430516425, -4.86575750771237E-5,-0.00234573131843931,
	-0.00532536253847712, -0.00881938374990202, -0.0125298792794148, -0.0160349103690561, -0.018813405060611,
	-0.0202891356213464, -0.0198903644123104, -0.0171195614002299, -0.0116253062362801, -0.00326657439016242,
	0.00784023827215585, 0.0212993822122494, 0.0364444562113838, 0.0523797566570426, 0.0680515698623637,
	0.0823424873483821,	0.09417875558847, 0.102638312576606, 0.107046310421825,	0.107046310421825,
	0.102638312576606, 0.09417875558847, 0.0823424873483821, 0.0680515698623637, 0.0523797566570426,
	0.0364444562113838, 0.0212993822122494, 0.00784023827215585, -0.00326657439016242, -0.0116253062362801,
	-0.0171195614002299, -0.0198903644123104, -0.0202891356213464, -0.018813405060611, -0.0160349103690561,
	-0.0125298792794148, -0.00881938374990202, -0.00532536253847712, -0.00234573131843931,
	-4.86575750771237E-5, 0.00151692430516425, 0.00239864483731844, 0.00271072221695493, 0.00260254806414593,
	0.00223040625529593, 0.00173493436088177, 0.001226644358132, 0.000780047144163945, 0.000433867017147087,
	0.000227909254804652 };
	
	# Initialize all array values to 0
	# Window is saved in the coroutine stack frame and therefore can
	# be stored as long as the coroutine is alive.
    window := array [60] of {float32 0.0, * => 0.0};

    y : array [100] of float32;
    x : array [100] of float32;

    acc1, acc2 : float32;

    i : int32;

    iterate
    {
        true =>
        {
			x = <- input;
			# Consume delay line and beginning of input samples
			sequence(i = 0; i < 61; i += 1)
			{
				acc1 = 0.0;
				sequence(j := int32 0; j < (i + 1); j += 1)
				{
					acc2 = x[i-j] * coeff[j];
					acc1 += acc2;
				};

				sequence(j = 0; j < (61 - i); j += 1)
				{
					acc2 = window[j] * coeff[i + j + 1];
					acc1 += acc2;
				};

				y[i] = acc1;
			};
                
			# Consume remaining input samples
			sequence(i = 0; i < (N - 61); i += 1)
			{
				acc1 = 0.0;
				sequence(j := int32 0; j < 62; j += 1)
				{
					acc2 = x[i-j + 61] * coeff[j];
					acc1 += acc2;
				};

				y[i + 61]= acc1;
			};

			# Update delay line for next frame
			sequence(i = 0; i < 61; i += 1)
			{
				window[60-i] = x[i + N - 61];
			};

			output <-= y;
		}
	};
}

lowPassFilter : function (nil) -> (nil) =
{
	i,k : int32;
	inputArr : array [100] of float32;


	firChan := load Filter->lowPassFilterOrder61 (path Filter);
        
	sequence(k = 0; k < M; k += N)
	{
		sequence(i = 0; i < N; i += 1)
		{
			inputArr[i] = float32 getXAccelerationMeasurement();
		};

		# Feed inputArr to fir implementation coroutine (write to channel)
		firChan <-= inputArr;

		# Take result from the output channel of the coroutine
		outputArr := <-firChan;

		sequence(i = 0; i < N; i += 1)
		{
			nil = noisyWarpPrintFloat32(x : outputArr[i]);
		};
	};
}
